지갑 생성 흐름
1) bip32
 SEED 생성 -> HD 지갑 생성 -> 지갑 주소 생성

2) bip39
 니모닉 단어 생성 -> SEED 생성 -> HD 지갑 생성 -> 지갑 주소 생성

3) bip44
 bip39에 용도별로 이름으로 나눠준 정도?


니모닉 단어 생성

1) 12개 문자

  1. 128비트의 무작위열(엔트로피) 생성
  2. 엔트로피 뒤에 checksum(엔트로피를 sha256 해싱한 값의 첫 4bit)를 붙여줌 (checksum의 길이는는 엔트로피 길이/32로 정한다)
  3. 엔트로피 132bit를 11bit씩 나누어 12개를 만든다
  4. 미리 정해진 단어 2048개에 맞추어 12개를 모두 연결시킨다. (11bit=2048, 해당하는 값에 따라 생성)
 

2) 24개 문자
  1. 256비트의 무작위열(엔트로피) 생성
  2. 엔트로피 뒤에 checksum(엔트로피를 sha256 해싱한 값의 첫 8bit)를 붙여줌 (checksum의 길이는는 엔트로피 길이/32로 정한다)
  3. 엔트로피 264bit를 11bit씩 나누어 24개를 만든다
  4. 미리 정해진 단어 2048개에 맞추어 24개를 모두 연결시킨다


SEED 생성 (KEY-STRETCHING 함수 - PBKDF2)
 - 마스터 노드를 생성하기 위한 512bit SEED 추출
 - HMAC-SHA512 사용
 - 유사난수 동작을 이용한 Brute-force attack을 어렵게 하기 위해 salt라는 보안 인수를 추가

  1. 니모닉 단어를 첫번째 변수로, 두번째 변수로 SALT를 받는다. (SALT는 "mnemonic"(문자열)+사용자가 제공하는 PASSPHRASE(option, 문자열)로 구성)
  2. PBKDF2는 HMAC-SHA512를 2048번 해싱하여 512bit 출력값을 생산한다.
  
  *. 1개의 니모닉 단어 + 여러개의 PASSPHRASE로 여러 개의 SEED를 만들 수 있다.


HD 지갑 생성
  1. SEED 512bit의 왼쪽 256bit를 master private key 로, 오른쪽 256bit를 master chain code로서 각각 HMAC을 이용하여 생성한다.
  2. master private key(개인키)로부터 master public key(공개키)를 생성한다.
  3. 부모 개인키 or 공개키 + 부모 chain code + 색인번호(32bit) 를 이용하여 HMAC-SHA512로 자식키 파생 
     ( [ 키, 체인코드 ]를 확장키라고 부름, k는 개인키, K는 공개키, c는 체인코드 )
  4. 확장키는 Base58Check을 이용하여 인코딩 되며, 서로 다른 BIP32 지갑들 사이에서 데이터를 쉽게 불러오고 전송할 수 있다.

  * 자식키 파생 방법
    - 자식키 유도(CKD) 함수 사용
    - pub parent key  -->  pub child key  (CKDpriv( (K,c), i ) -> (K(i), c(i)) )
    - priv parent key  -->  priv child key   (CKDpub( (k,c), i ) -> (k(i), c(i)) )
    - priv parent key  -->  pub child key   (N(CKDpriv( (k,c), i ) -> (K(i), c(i)) )

  * 비강화 키가 좋지 않은 이유
    - k는 자식키, c는 부모 체인코드, pk는 부모 키
    - k(i) = pk(i) + hash(PK(i), c(i), i)
    - pk(i) = k(i) - hash(PK(i), c(i), i)
    - pk(i) * G = k(i) * g - hash(PK(i), c(i), i) * G
    - PK(i) = K(i) - hash(PK(i), c(i), i) * G
      xpub을 알고 개인키를 알게 되면 부모 개인키 유출 가능성?(이해도가 떨어짐.. 타원곡선알고리즘 공부)



 한 개의 개인키 -> 여러개의 암호화폐 가능 (해시 방식에 따라 비트-ripemd, 이더-keccak?)
 